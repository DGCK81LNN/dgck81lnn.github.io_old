<!docvariant html>
<html lang=cmn>
<!--
  这是灵魂小站 / 应用 / 灵魂实验室 / brainfuck 在线工具!
  ID: apps.lab.bf // soullbf
-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="format-detection" content="telephone=no">
  <link rel="stylesheet" href="/css/commons.css">
  <link rel="stylesheet" href="/lib/prism.css">
  <link rel="stylesheet" href="/apps/lab/lab_components.css"></script>
  <link rel="icon" href="/site_icon.png">
  <link rel="shortcut icon" href="/site_icon.png">
  <link rel="apple-touch-icon" href="/site_icon.png" sizes="160x160">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es2015%2CIntersectionObserver"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/bootstrap-vue/2.21.0/bootstrap-vue.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/bootstrap-vue/2.21.0/bootstrap-vue-icons.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/vue-resource/1.5.1/vue-resource.min.js"></script>
  <script src="/lib/prism.js"></script>
  <script src="/js/commons.js"></script>
  <script src="/apps/lab/lab_components.js"></script>
  <title>brainfuck 在线调试器 - 灵魂小站</title>
  <style>
    .soullbf-toolbar-row {
      display: inline-block;
      margin: 5px;
    }
    .soullbf-memory-table {
      overflow-x: auto;
      padding: 0 0.5rem;
      margin: 1rem 0;
    }
    .soullbf-memory-table td,
    .soullbf-memory-table th {
      height: 1.5em;
      min-width: 1.5rem;
      border-radius: 4px;
      background: #ebeef5;
      font-family: var(--soul-font-family-monospace);
      text-align: center;
    }
    .soullbf-memory-table .soullbf-pointer {
      background: #ffbebe;
    }
    .soullbf-left,
    .soullbf-right {
      width: 50%;
      height: 350px;
      overflow-y: auto;
      box-sizing: border-box;
      padding: 1rem 0.5rem;
    }
    .soullbf-left {
      float: left;
    }
    .soullbf-code-input {
      height: 100%;
      box-sizing: border-box;
    }
    .soullbf-code-input>code {
      height: 100%;
      box-sizing: border-box;
      color: transparent;
      background-color: transparent;
      overflow-y: -moz-scrollbars-none;
      -ms-overflow-style: none;
    }
    .soullbf-right {
      float: right;
    }
    .soullbf-right>textarea {
      height: 100%;
    }
    .soullbf-wrapcode code {
      white-space: pre-wrap !important;
      overflow-wrap: break-word;
    }

    textarea {
      font-family: var(--soul-font-family-monospace);
      resize: none !important;
    }

    .b-sidebar {
      min-width: 250px;
    }
    .b-sidebar {
      min-width: 300px;
    }
    .b-sidebar__body {
      padding: 20px;
    }
    .soullbf-drawer-config .b-sidebar__body {
      overflow-y: auto;
    }

    .token.soullbf-error {
      background: #E1001A;
      color: #f5f2f0;
      text-shadow: none;
    }
    .token.soullbf-breakpoint {
      background: #58000a;
      color: #f5f2f0;
      text-shadow: none;
    }
    .token.soullbf-pointer {
      background: #ffbebe;
    }
    .token.soullbf-pointer.soullbf-breakpoint {
      background: #E1001A;
    }
    @keyframes cursor {
      0% {
        background: transparent;
      }
      50% {
        background: #ffbebe;
      }
      100% {
        background: transparent;
      }
    }
    .token.soullbf-cursor {
      animation: cursor 1s infinite;
    }

    @media screen and (max-width: 700px) {
      .soullbf-left, .soullbf-right {
        float: none;
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <soul-header></soul-header>
    <soul-main>
      <b-breadcrumb>
        <b-breadcrumb-item href="/home">主站</b-breadcrumb-item>
        <b-breadcrumb-item href="/apps">应用</b-breadcrumb-item>
        <b-breadcrumb-item href="/apps/lab">灵魂实验室</b-breadcrumb-item>
        <b-breadcrumb-item active>brainfuck 在线工具</b-breadcrumb-item>
      </b-breadcrumb>

      <div v-if="panel === 'edit'">
        <section class="soullbf-toolbar">
          <b-button
          variant=primary
          @click="init()"
          :disabled="syntaxError"
          ><b-icon icon=caret-right aria-hidden=true></b-icon> 准备</b-button>
          <b-button
          variant=info
          v-b-toggle.config-drawer
          ><b-icon icon=gear aria-hidden=true></b-icon> 环境选项</b-button>
          <b-button
          :disabled="syntaxError"
          v-b-popover.hover="'此功能即将到来...'"
          variant="outline-secondary"
          ><b-icon icon=cpu aria-hidden=true></b-icon> 编译</b-button>
        </section>
        <section class="soullbf-main">
          <section class="soullbf-left">
            <soul-fake-textarea
            class="soullbf-code-input"
            :value="code"
            :handle-input="handleInput"
            ></soul-fake-textarea>
          </section>
          <section class="soullbf-right">
            <b-form-textarea
            v-model="input"
            placeholder="输入流。模拟从文本文件中读取输入。留空则启动命令行模式。"
            :disabled="stat !== 'ready'"
            ></b-form-input>
          </section>
        </section>
      </div>
      <div v-if="panel === 'run'">
        <b-alert v-if="message" show :variant="message.variant" fade v-text="message.text"></b-alert>
        <section class="soullbf-toolbar">
          <b-button
          v-if="stat === 'pause'"
          variant=primary
          @click="run()"
          ><b-icon icon=caret-right aria-hidden=true></b-icon> 运行</b-button>
          <b-button
          v-if="stat === 'pause'"
          @click="step()"
          ><b-icon icon=arrow-right-short aria-hidden=true></b-icon> 运行一步</b-button>
          <b-button
          v-if="stat === 'run'"
          variant=danger
          @click="pause()"
          ><b-icon icon=pause aria-hidden=true></b-icon> 暂停</b-button>
          <b-button
          v-else
          variant=danger
          @click="reset()"
          ><b-icon icon=trash aria-hidden=true></b-icon> 退出</b-button>
        </section>
        <section class="soullbf-memory-table" v-if="stat !== 'ready'">
          <table>
            <tr>
              <th
              v-for="kvPair in renderMemory()"
              :key="kvPair[0]"
              :rowspan="kvPair[1] === undefined ? 2 : ''"
              :class="memory.pointer === kvPair[0] ? 'soullbf-pointer' : ''"
              v-text="kvPair[1] === undefined ? '...' : kvPair[0]"
              ></th>
            </tr>
            <tr>
              <td
              v-for="kvPair in renderMemory()"
              v-if="kvPair[1] !== undefined"
              :key="kvPair[0]"
              :class="memory.pointer === kvPair[0] ? 'soullbf-pointer' : ''"
              v-text="kvPair[1]"
              ></td>
            </tr>
          </table>
        </section>
        <p>点击代码中带高亮的指令来添加断点。</p>
        <section class="soullbf-main">
          <section class="soullbf-left">
            <soul-manual-prism
            class="soullbf-wrapcode"
            @click="codeClick"><span
            v-for="(instruction, i) in [...code]"
            :class="[
              'token',
              instruction === '>' || instruction === '<' ? 'pointer keyword'
              : instruction === '+' ? 'increment inserted'
              : instruction === '-' ? 'decrement deleted'
              : instruction === '.' || instruction === ',' ? 'operator'
              : instruction === '[' || instruction === ']' ? 'branching important'
              : 'comment',
              i === codePointer ? 'soullbf-pointer' : '',
              breakpoints.has(i) ? 'soullbf-breakpoint' : ''
            ]"
            :data-i="i"
            v-text="instruction === '\n' ? ' \n' : instruction"
            ></span></soul-manual-prism>
          </section>
          <section v-if="staticInput" class="soullbf-right">
            <soul-manual-prism class="soullbf-wrapcode">{{input.slice(0, inputPointer)}}<span class="token soullbf-pointer">{{input[inputPointer] === '\n' ? ' \n': input[inputPointer] || ' '}}</span>{{input.slice(inputPointer + 1)}}</soul-manual-prism>
            <soul-manual-prism class="soullbf-wrapcode">{{output}}<span class="token soullbf-pointer">&nbsp;</span></soul-manual-prism>
          </section>
          <section v-else class="soullbf-right">
            <soul-manual-prism class="soullbf-wrapcode">{{output}}<span v-if="waitingForInput" class="token comment">{{inputBuffer}}<span class="token soullbf-cursor">&nbsp;</span></span><span v-else class="token soullbf-pointer">&nbsp;</span></soul-manual-prism>
            <div @keyup.enter="inputBufferKeypress">
              <b-input-group v-if="waitingForInput">
                <template #append>
                  <b-button
                  slot="append"
                  @click="inputBufferEnded"
                  ><b-icon icon=file-earmark-check aria-hidden=true></b-icon> 全文结束</b-button>
                </template>
                <b-form-input v-model="inputBuffer"></b-form-input>
              </b-input-group>
            </div>
          </section>
        </section>
      </div>
      <div v-if="panel === 'compile'">
        <!-- TODO: Add compiler (?) -->
      </div>
    </soul-main>

    <soul-footer :links="[
      { href: 'https://esolangs.org/wiki/brainfuck', text: 'brainfuck - Esolangs 维基' },
      { href: 'http://mazonka.com/brainf/10.html', text: 'Oleg Mazonka 写的 brainf 自举' },
      { href: 'https://tio.run/#brainfuck', text: '在 TryItOnline 上运行 brainf' },
      { href: 'https://fatiherikli.github.io/brainfuck-visualizer', text: 'Fatih Erikli 制作的 brainf 可视化' }
    ]"></soul-footer>


    <b-modal
    title="设置逐步运行速度"
    id="tick-speed-dialog"
    header-close-label="关闭"
    >
      <b-form-input type=number
      v-model="tickSpeed"
      :min="10"
      :step="50"
      ></b-form-input type=number>
      <p>间隔毫秒数，输入10以上的整数。</p>
    </b-modal>

    <b-sidebar
    title="环境配置"
    class="soullbf-drawer-config"
    id="config-drawer"
    right
    backdrop shadow
    close-label="关闭"
    >
      <div class="px-3 py-2">
        <b-form-group label="EOF">
          <b-form-radio-group
          v-model="config.eof"
          size=small
          buttons button-variant=outline-secondary>
            <b-form-radio :value=undefined>保持不变</b-form-radio>
            <b-form-radio :value=-1>读入-1</b-form-radio>
            <b-form-radio :value=0>读入0</b-form-radio>
          </b-form-radio-group>
          <p class="soul-p2">
            设置使用“输入流”时EOF的表示方式。标准文档说应当保持单元格中原来的值不变，但原版编译器会读入-1，也有很多编译器/解释器会读入0。有些brainfuck程序可以兼容“保持不变”以及“读入-1”和“读入0”的其中一个。
          </p>
        </b-form-group>
        <b-form-group label="数据类型">
          <b-form-select size=md v-model="config.dataType">
            <b-form-select-option :value=1>8位</b-form-select-option>
            <b-form-select-option :value=2>16位</b-form-select-option>
            <b-form-select-option :value=4>32位</b-form-select-option>
            <b-form-select-option :value=8 :disabled="bigIntNotSupported">64位</b-form-select-option>
            <b-form-select-option :value=99 :disabled="bigIntNotSupported">无限</b-form-select-option>
            <b-form-select-option v-if="bigIntNotSupported" value disabled>
              您的浏览器不支持BigInt，“64位”和“无限”无法使用。
            </b-form-select-option>
          </b-form-select>
        </b-form-group>
        <b-form-group label="单元格数量">
          <b-form-select size=md v-model="config.cells" @change="ucellsChange">
            <b-form-select-option :value="30000">30000</b-form-select-option>
            <b-form-select-option :value="5000">5000</b-form-select-option>
            <b-form-select-option :value="100">100</b-form-select-option>
            <b-form-select-option :value="Infinity">无限</b-form-select-option>
            <b-form-select-option :value="undefined">自定义...</b-form-select-option>
          </b-form-select>
        </b-form-group>
        <b-form-group :label="config.cells === Infinity ? '负数指针' : '指针越界'">
          <b-form-radio-group
          v-model="config.allowNegativeMP"
          size=small
          buttons button-variant=outline-secondary
          >
            <b-form-radio :value="false">{{config.cells === Infinity ? '不允许' : '停止运行'}}</b-form-radio>
            <b-form-radio :value="true">{{config.cells === Infinity ? '允许' : '跳到另一端'}}</b-form-radio>
          </b-form-radio-group>
        </b-form-group>
      </div>
    </b-sidebar>

    <b-modal
    title="自定义单元格数量"
    id="custom-cells-dialog"
    ok-only
    header-close-label="关闭"
    >
      <b-form-input
      type=number
      size=md
      v-model="config._cells"
      @change="cellsChange"
      :min=3
      :max=65535
      ></b-form-input>
      <p>输入3到65535之间的整数。</p>
    </b-modal>
  </div>
  <script>

    if (!"_test" in this) var _test = -Infinity;

    const escapeLNN = str =>
      str.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/ /g, "&#32;")
        .replace(/\n/g, "<br>");

    class SoullbfMemory extends Map {
      constructor(dataType, cells) {
        super();
        let finiteCells = cells !== Infinity;
        let isBigInt = dataType >= 8;
        let overflow = isBigInt ? BigInt(1) << BigInt(63) : 2 ** (dataType * 8 - 1);
        let m = overflow + overflow;
        this.fixOverflow = dataType == 99 ? (v) => v : v => {
          let v_ = isBigInt ? BigInt(v) : Math.floor(v);
          if (v_ !== v_) throw new TypeError("数据不能是NaN");
          if (v_ === Infinity || v_ === -Infinity) throw new RangeError("数据不能是无穷大");
          v_ = (v_ + overflow) % m;
          if (v_ < 0) v_ += m;
          return v_ - overflow;
        };
        this.pointer = 0;
        this.dataType = dataType, this.cells = cells, this.finiteCells = finiteCells, this.isBigInt = isBigInt;
        super.set(0, isBigInt ? BigInt(0) : 0);
        this.haltOnPointerOverflow = false;
      }
      getCurr() {
        return super.get(this.pointer);
      }
      setCurr(v) {
        if (v !== undefined)
          super.set(this.pointer, this.fixOverflow(v));
      }
      increment(i) {
        let v = super.get(this.pointer);
        super.set(this.pointer, this.fixOverflow(++v));
      }
      decrement(i) {
        let v = super.get(this.pointer);
        super.set(this.pointer, this.fixOverflow(--v));
      }
      right(i) {
        this.pointer++;
        if (this.pointer >= this.cells) {
          if (this.haltOnPointerOverflow)
            throw new Error("指针越界！");
          else
            this.pointer -= this.cells;
        }
        if (!super.has(this.pointer))
          super.set(this.pointer, this.isBigInt ? BigInt(0) : 0);
      }
      left(i) {
        this.pointer--;
        if (this.pointer < 0) {
          if (this.haltOnPointerOverflow)
            throw new Error("指针越界！");
          else if (this.finiteCells)
            this.pointer += this.cells;
        }
        if (!super.has(this.pointer))
          super.set(this.pointer, this.isBigInt ? BigInt(0) : 0);
      }
    }

    var intHandle;

    const vm = new Vue({
      el: "#app",
      
      data: {
        bigIntNotSupported: _test < 6,

        codeInputScrollTop: 0,

        code: `>+++++[-<+++++>]
>++++++++[-<++++++++>]
++++[->++++<]>[-<++++++>]
>++++[-<++++++++>]
<<<<+[->+.>+.>.<<<]
++++++++++.`,
        codeHighlight: "",
        syntaxError: false,
        
        config: {
          eof: undefined, // {undefined: no_change, -1, 0}
          dataType: 1, // {1: Int8, 2: Int16, 4: Int32, 8: Int64, 99: BigInt}
          _cells: 30000,
          cells: 30000, // {(int), Infinity}
          allowNegativeMP: false,
        },

        tickSpeed: 300,

        panel: "edit", //edit, run, compile
        stat: "ready", // ready, run, pause, end
        codePointer: 0,
        breakpoints: new Set(),
        memory: null,
        staticInput: true,
        input: "",
        inputPointer: 0,
        inputBuffer: "",
        inputBufferEOF: false,
        waitingForInput: false,
        output: "",

        leaveLoopDepth: 0,

        message: null
      },

      methods: {
        handleInput(raw, offset) {
          vm.code = raw;
          let frag = document.createDocumentFragment(),
            line = document.createElement("div"),
            token = null, text = null;
          let i = 0, l = raw.length, depth = 0, error = false, newLine = true;
          let caretNode = null, caretOffset = 1;
          if (i === 0 && offset === 0)
            caretNode = line, caretOffset = 0;
          while (i < l) {
            let char = raw[i++];
            if (char === "\n") {
              if (newLine) {
                text = document.createElement("br"),
                line.appendChild(text);
              }
              newLine = true;
              frag.appendChild(line);
              line = document.createElement("div");
              if (i === offset)
                caretNode = line, caretOffset = 0;
            } else {
              newLine = false;
              token = document.createElement("span"), text = document.createTextNode(char);
              token.classList.add("token");
              if (char === "+")
                token.classList.add("increment", "inserted");
              else if (char === "-")
                token.classList.add("decrement", "deleted");
              else if (char === "<" || char === ">")
                token.classList.add("pointer", "keyword");
              else if (char === "." || char === ",")
                token.classList.add("operator", "inserted");
              else if (char === "[")
                depth++, token.classList.add("branching", "important");
              else if (char === "]") {
                depth--, token.classList.add("branching", "important");
                if (depth < 0) 
                  depth = 0, error = true, token.classList.add("soullbf-error");
              } else
                token.classList.add("comment");
              token.appendChild(text);
              line.appendChild(token);
              if (i === offset)
                  caretNode = text, caretOffset = 1;
            }
            //console.log({i, depth, newLine, caretNode, caretOffset});
          }
          if (depth > 0)
            error = true,
            token.classList.add("soullbf-error");
          vm.syntaxError = error;
          if (newLine)
            line.appendChild(document.createElement("br"));
          frag.appendChild(line);
          return {
            renderedNode: frag,
            caretNode,
            caretOffset
          };
        },

        ucellsChange(v){
          if (v === undefined) {
            vm.config.cells = vm.config._cells;
            vm.$bvModal.show('custom-cells-dialog');
          }
          else
            vm.config._cells = v;
        },
        cellsChange(v){
          vm.config.cells = v;
        },

        renderMemory() {
          let m = [...vm.memory.entries()], r = [], i = vm.config.cells === Infinity && vm.config.allowNegativeMP ? -Infinity : -1;
          m.sort((l, r) => l[0] - r[0]);
          m.forEach((v) => {
            if (v[0] !== i + 1)
              r.push([i]);
            i = v[0];
            r.push(v);
          });
          if (vm.config.cells !== i + 1)
            r.push([i + 1]);
          return r;
        },

        inputBufferKeypress($event) {
          vm.input = vm.inputBuffer + "\n", vm.inputPointer = 0, vm.output += vm.input, vm.inputBuffer = "";
        },
        inputBufferEnded() {
          vm.inputBufferEOF = true;
          vm.input = vm.inputBuffer, vm.inputPointer = 0, vm.output += vm.input + "^C" + "\n", vm.inputBuffer = "";
        },

        codeClick($event) {
          let i = $event.target.dataset.i;
          if (i) {
            i = Number(i);
            if (vm.breakpoints.has(i))
              vm.breakpoints.delete(i);
            else if("><+-.,[]".includes(vm.code[i]))
              vm.breakpoints.add(i);
            vm.$forceUpdate();
          }
        },

        panelChange() {
          if (vm.panel === "edit")
            vm.reset();
          else if (vm.panel === "run")
            vm.init();
        },

        iStep() {
          let instruction = vm.code[vm.codePointer], cond = true;
          while (cond) {
            cond = false;
            if (instruction === undefined) 
              throw "程序退出！";
            
            switch (instruction) {
              case '>':
                vm.memory.right();
              break; case '<':
                vm.memory.left();
              break; case '+':
                vm.memory.increment();
              break; case '-':
                vm.memory.decrement();
              break; case '.':
                vm.output += String.fromCharCode(Number(vm.memory.getCurr()));
              break; case ',':
                if (vm.inputPointer < vm.input.length)
                  vm.waitingForInput = false, vm.memory.setCurr(vm.input.charCodeAt(vm.inputPointer++));
                else if (vm.staticInput || vm.inputBufferEOF)
                  vm.memory.setCurr(vm.config.eof);
                else {
                  vm.waitingForInput = true;
                  return;
                }
              break; case '[':
                let i3 = vm.code.substr(vm.codePointer), curr = vm.memory.getCurr();
                if (
                  i3.match(/^\[([^><+-.,[\]]*)\-([^><+-.,[\]]*)\]/) && (vm.config.dataType !== 99 || curr > 0) ||
                  i3.match(/^\[([^><+-.,[\]]*)\+([^><+-.,[\]]*)\]/) && (vm.config.dataType !== 99 || curr < 0)
                )
                  vm.memory.setCurr(0), vm.codePointer += 2;
                else if (!curr) {
                  let depth = 1;
                  while (depth) {
                    instruction = vm.code[++vm.codePointer];
                    if (instruction === '[')
                      depth++;
                    else if (instruction === ']')
                      depth--;
                  }
                }
              break; case ']':
                if (vm.memory.getCurr()) {
                  let depth = 1;
                  while (depth) {
                    instruction = vm.code[--vm.codePointer];
                    if (instruction === ']')
                      depth++;
                    else if (instruction === '[')
                      depth--;
                  }
                }
              break; default:
                cond = true;
              break;
            }
            if (vm.output.length >= 131072)
              throw new Error("输出过长！");
            do
              instruction = vm.code[++vm.codePointer];
            while (instruction && !"><+-.,[]".includes(instruction));
          }
          if (vm.breakpoints.has(vm.codePointer))
            throw "break";
          vm.$nextTick(() => {
            let mt = vm.$el.querySelector(".soullbf-memory-table"),
              mp = mt.querySelector(".soullbf-pointer");
            if (mt && mp)
              mt.scrollLeft = mp.offsetLeft - mt.offsetWidth / 2;
            if (instruction === '.')
              vm.$el.querySelector(".soullbf-right").scrollTop = 2147483647;
          });
        },

        iHandleError(e) {
          clearTimeout(vm.intHandle);
            if (e instanceof Error) {
              vm.stat = 'end';
              vm.iShowMessage('danger', e);
              console.error(e);
            }
            else if(e === "break") {
              vm.stat = 'pause';
            }
            else {
              vm.stat = 'end';
              vm.iShowMessage('success', e);
            }
        },

        iShowMessage(variant, text) {
          vm.message = { variant, text };
        },

        init() {
          vm.panel = 'run';
          vm.stat = 'pause';
          vm.codePointer = 0;
          vm.inputPointer = 0;
          vm.output = "";
          vm.inputBuffer = "";
          vm.memory = new SoullbfMemory(vm.config.dataType, vm.config.cells);
          vm.memory.haltOnPointerOverflow = !vm.config.allowNegativeMP;
          vm.staticInput = Boolean(vm.input);
          vm.breakpoints = new Set();
          vm.inputBufferEOF = false;
          vm.message = null;
        },
        run() {
          vm.stat = 'run';
          let f = () => {
            let end = Date.now() + 30;
            try {
              do
                vm.iStep();
              while (Date.now() < end);
              vm.intHandle = setTimeout(f, 10);
            } catch (e) {
              vm.iHandleError(e);
            }
          };
          f();
        },
        step() {
          vm.stat = 'pause';
          try {
            vm.iStep();
          } catch (e) {
            vm.iHandleError(e);
          }
        },
        pause() {
          vm.stat = 'pause';
          clearTimeout(vm.intHandle);
        },
        reset() {
          vm.stat = 'ready';
          vm.panel = 'edit';
          vm.codePointer = 0;
          vm.memory = null;
          if (!vm.staticInput)
            vm.input = "";
          vm.waitingForInput = false;
        },
      }
    });
  </script>
</body>

</html>
