<!doctype html>
<html lang="cmn">
<!--
  这是灵魂小站 / 应用 / 灵魂实验室 / brainfuck 在线工具!
  ID: apps.lab.bf // soullbf
-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <link rel="stylesheet" href="/lib/element.css">
  <link rel="stylesheet" href="/css/commons.css">
  <link rel="stylesheet" href="/css/prism.css">
  <link rel="stylesheet" href="/apps/lab/lab_components.css">
  <link rel="icon" href="/site_icon.png">
  <link rel="shortcut icon" href="/site_icon.png">
  <link rel="apple-touch-icon" href="/site_icon.png" sizes="160x160">
  <script src="/js/tests.js"></script>
  <!--<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>-->
  <script src="/lib/vue.min.js"></script>
  <script src="https://unpkg.com/element-ui/lib/index.js"></script>
  <script src="https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js"></script>
  <script src="/js/prism.js"></script>
  <script src="/js/commons.js"></script>
  <script src="/apps/lab/lab_components.js"></script>
  <title>brainfuck 在线调试器 - 灵魂小站</title>
  <style>
    .soullbf-toolbar-row {
      display: inline-block;
      margin: 5px;
    }
    .soullbf-memory-table {
      overflow-x: auto;
      padding: 0 0.5rem;
      margin: 1rem 0;
    }
    .soullbf-memory-table td,
    .soullbf-memory-table th {
      height: 1.5em;
      min-width: 1.5rem;
      border-radius: 4px;
      background: #ebeef5;
      font-family: var(--soul-font-family-monospace);
      text-align: center;
    }
    .soullbf-memory-table .soullbf-pointer {
      background: #ffbebe;
    }
    .soullbf-left,
    .soullbf-right {
      width: 50%;
      height: 350px;
      overflow-y: auto;
      box-sizing: border-box;
      padding: 1rem 0.5rem;
    }
    .soullbf-left {
      float: left;
    }
    .soullbf-code-input {
      height: 100%;
      box-sizing: border-box;
    }
    .soullbf-code-input>code {
      height: 100%;
      box-sizing: border-box;
      color: transparent;
      background-color: transparent;
      overflow-y: -moz-scrollbars-none;
      -ms-overflow-style: none;
    }
    .soullbf-right {
      float: right;
    }
    .soullbf-right>.el-textarea,
    .soullbf-right>.el-textarea>textarea {
      height: 100%;
    }
    .soullbf-wrapcode code {
      white-space: pre-wrap !important;
      overflow-wrap: break-word;
    }

    textarea {
      font-family: var(--soul-font-family-monospace);
      resize: none !important;
    }

    .el-dialog {
      min-width: 250px;
    }
    .el-drawer {
      min-width: 300px;
    }
    .el-drawer__body {
      padding: 20px;
    }
    .soullbf-drawer-config .el-drawer__body {
      overflow-y: auto;
    }

    .token.soullbf-error {
      background: #E1001A;
      color: #f5f2f0;
      text-shadow: none;
    }
    .token.soullbf-breakpoint {
      background: #58000a;
      color: #f5f2f0;
      text-shadow: none;
    }
    .token.soullbf-pointer {
      background: #ffbebe;
    }
    .token.soullbf-pointer.soullbf-breakpoint {
      background: #E1001A;
    }
    @keyframes cursor {
      0% {
        background: transparent;
      }
      50% {
        background: #ffbebe;
      }
      100% {
        background: transparent;
      }
    }
    .token.soullbf-cursor {
      animation: cursor 1s infinite;
    }

    @media screen and (max-width: 700px) {
      .soullbf-left, .soullbf-right {
        float: none;
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <soul-header default-active="apps"></soul-header>
    <soul-main>
      <el-breadcrumb separator-class="el-icon-arrow-right">
        <el-breadcrumb-item><a href="/apps">应用</a></el-breadcrumb-item>
        <el-breadcrumb-item><a href=".">灵魂实验室</a></el-breadcrumb-item>
        <el-breadcrumb-item>brainfuck 在线工具</el-breadcrumb-item>
      </el-breadcrumb>

      <div v-if="panel === 'edit'">
        <section class="soullbf-toolbar">
          <el-button
          type="primary"
          icon="el-icon-caret-right"
          @click="init()"
          :disabled="syntaxError"
          >准备</el-button>
          <el-button
          type="info"
          icon="el-icon-setting"
          @click="configVisible = true"
          >环境选项</el-button>
          <el-button
          plain
          icon="el-icon-cpu"
          @click="$alert('此功能即将到来...')"
          :disabled="syntaxError"
          >编译</el-button>
        </section>
        <section class="soullbf-main">
          <section class="soullbf-left">
            <soul-fake-textarea
            class="soullbf-code-input"
            :value="code"
            :handle-input="handleInput"
            ></soul-fake-textarea>
          </section>
          <section class="soullbf-right">
            <el-input
            type="textarea"
            v-model="input"
            placeholder="输入流。模拟从文本文件中读取输入。留空则启动命令行模式。"
            :disabled="stat !== 'ready'"
            ></el-input>
          </section>
        </section>
      </div>
      <div
      label="运行"
      name="run"
      v-if="panel === 'run'">
        <section class="soullbf-toolbar">
          <el-button
          v-if="stat === 'pause'"
          type="primary"
          icon="el-icon-caret-right"
          @click="run()"
          >运行</el-button>
          <el-button
          v-if="stat === 'pause'"
          plain
          icon="el-icon-right"
          @click="step()"
          >运行一步</el-button>
          <el-button
          v-if="stat === 'run'"
          type="danger" plain
          icon="el-icon-video-pause"
          @click="pause()"
          >暂停</el-button>
          <el-button
          v-else
          type="danger"
          icon="el-icon-delete"
          @click="reset()"
          >退出</el-button>
        </section>
        <section class="soullbf-memory-table" v-if="stat !== 'ready'">
          <table>
            <tr>
              <th
              v-for="kvPair in renderMemory()"
              :key="kvPair[0]"
              :rowspan="kvPair[1] === undefined ? 2 : ''"
              :class="memory.pointer === kvPair[0] ? 'soullbf-pointer' : ''"
              v-text="kvPair[1] === undefined ? '...' : kvPair[0]"
              ></th>
            </tr>
            <tr>
              <td
              v-for="kvPair in renderMemory()"
              v-if="kvPair[1] !== undefined"
              :key="kvPair[0]"
              :class="memory.pointer === kvPair[0] ? 'soullbf-pointer' : ''"
              v-text="kvPair[1]"
              ></td>
            </tr>
          </table>
        </section>
        <p>点击代码中带高亮的指令来添加断点。</p>
        <section class="soullbf-main">
          <section class="soullbf-left">
            <soul-manual-prism
            class="soullbf-wrapcode"
            @click="codeClick"><span
            v-for="(instruction, i) in [...code]"
            :class="[
              'token',
              instruction === '>' || instruction === '<' ? 'pointer keyword'
              : instruction === '+' ? 'increment inserted'
              : instruction === '-' ? 'decrement deleted'
              : instruction === '.' || instruction === ',' ? 'operator'
              : instruction === '[' || instruction === ']' ? 'branching important'
              : 'comment',
              i === codePointer ? 'soullbf-pointer' : '',
              breakpoints.has(i) ? 'soullbf-breakpoint' : ''
            ]"
            :data-i="i"
            v-text="instruction === '\n' ? ' \n' : instruction"
            ></span></soul-manual-prism>
          </section>
          <section v-if="staticInput" class="soullbf-right">
            <soul-manual-prism class="soullbf-wrapcode">{{input.slice(0, inputPointer)}}<span class="token soullbf-pointer">{{input[inputPointer] === '\n' ? ' \n': input[inputPointer] || ' '}}</span>{{input.slice(inputPointer + 1)}}</soul-manual-prism>
            <soul-manual-prism class="soullbf-wrapcode">{{output}}<span class="token soullbf-pointer">&nbsp;</span></soul-manual-prism>
          </section>
          <section v-else class="soullbf-right">
            <soul-manual-prism class="soullbf-wrapcode">{{output}}<span v-if="waitingForInput" class="token comment">{{inputBuffer}}<span class="token soullbf-cursor">&nbsp;</span></span><span v-else class="token soullbf-pointer">&nbsp;</span></soul-manual-prism>
            <div @keyup.enter="inputBufferKeypress">
              <el-input
              v-if="waitingForInput"
              v-model="inputBuffer"
              >
                <el-button
                slot="append"
                icon="el-icon-document-checked"
                @click="inputBufferEnded"
                >全文结束</el-button>
              </el-input>
            </div>
          </section>
        </section>
      </div>
      <div v-if="panel === 'compile'">
        
      </div>
      </el-tabs>



    </soul-main>
    <soul-footer :links="[
      { href: 'https://esolangs.org/wiki/brainfuck', text: 'brainfuck - Esolangs 维基' },
      { href: 'http://mazonka.com/brainf/10.html', text: 'Oleg Mazonka 写的 brainf 自举' },
      { href: 'https://tio.run/#brainfuck', text: '在 TryItOnline 上运行 brainf' },
      { href: 'https://fatiherikli.github.io/brainfuck-visualizer', text: 'Fatih Erikli 制作的 brainf 可视化' }
    ]"></soul-footer>


    <el-dialog title="设置逐步运行速度"
    :visible.sync="tickSpeedVisible"
    width="30%">
      <el-input-number
      v-model="tickSpeed"
      :min="10"
      :step="50"
      ></el-input-number>
      <p>间隔毫秒数，输入10以上的整数。</p>
      <span slot="footer">
        <el-button @click="tickSpeedVisible = false">完成</el-button>
      </span>
    </el-dialog>

    <el-drawer title="环境配置"
    class="soullbf-drawer-config"
    :visible.sync="configVisible"
    direction="rtl"
    >
      <el-form :model="config">
        <el-form-item label="EOF">
          <el-radio-group v-model="config.eof" size="small">
            <el-radio-button :label="undefined">保持不变</el-radio-button>
            <el-radio-button :label="-1">读入-1</el-radio-button>
            <el-radio-button :label="0">读入0</el-radio-button>
          </el-radio-group>
          <p class="soul-p2">
            设置使用“输入流”时EOF的表示方式。标准文档说应当保持单元格中原来的值不变，但原版编译器会读入-1，也有很多编译器/解释器会读入0。有些brainfuck程序可以兼容“保持不变”以及“读入-1”和“读入0”的其中一个。
          </p>
        </el-form-item>
        <el-form-item label="数据类型">
          <el-select size="medium" v-model="config.dataType">
            <el-option label="8位" :value="1"></el-option>
            <el-option label="16位" :value="2"></el-option>
            <el-option label="32位" :value="4"></el-option>
            <el-option label="64位" :value="8" :disabled="bigIntNotSupported"></el-option>
            <el-option label="无限" :value="99" :disabled="bigIntNotSupported"></el-option>
            <el-option v-if="bigIntNotSupported" value disabled>
              您的浏览器不支持BigInt，“64位”和“无限”无法使用。
            </el-option>
          </el-select>
        </el-form-item>
        <el-form-item label="单元格数量">
          <el-select size="medium" v-model="config.cells" @change="ucellsChange">
            <el-option-group>
              <el-option label="30000" :value="30000"></el-option>
              <el-option label="5000" :value="5000"></el-option>
              <el-option label="100" :value="100"></el-option>
              <el-option label="无限" :value="Infinity"></el-option>
            </el-option-group>
            <el-option-group>
              <el-option label="自定义..." :value="undefined"></el-option>
            </el-option-group>
          </el-select>
        </el-form-item>
        <el-form-item :label="config.cells === Infinity ? '负数指针' : '指针越界'">
          <el-radio-group v-model="config.allowNegativeMP" size="small">
            <el-radio-button :label="false">{{config.cells === Infinity ? '不允许' : '停止运行'}}</el-radio-button>
            <el-radio-button :label="true">{{config.cells === Infinity ? '允许' : '跳到另一端'}}</el-radio-button>
          </el-radio-group>
        </el-form-item>
      </el-form>
    </el-drawer>

    <el-dialog title="自定义单元格数量"
    :visible.sync="customCellsVisible"
    width="30%">
      <el-input-number
      size="medium"
      v-model="config._cells"
      @change="cellsChange"
      :min="3"
      :max="65535"
      :step="1"
      step-strictly
      :controls="false"
      ></el-input-number>
      <p>输入3到65535之间的整数。</p>
      <span slot="footer">
        <el-button @click="customCellsVisible = false">完成</el-button>
      </span>
    </el-dialog>
  </div>
</body>
<script>

  if (!"_test" in this) var _test = -Infinity;

  const escapeLNN = str =>
    str.replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/ /g, "&#32;")
      .replace(/\n/g, "<br>");

  class SoullbfMemory extends Map {
    constructor(dataType, cells) {
      super();
      let finiteCells = cells !== Infinity;
      let isBigInt = dataType >= 8;
      let overflow = isBigInt ? BigInt(1) << BigInt(63) : 2 ** (dataType * 8 - 1);
      let m = overflow + overflow;
      this.fixOverflow = dataType == 99 ? (v) => v : v => {
        let v_ = isBigInt ? BigInt(v) : Math.floor(v);
        if (v_ !== v_) throw new TypeError("数据不能是NaN");
        if (v_ === Infinity || v_ === -Infinity) throw new RangeError("数据不能是无穷大");
        v_ = (v_ + overflow) % m;
        if (v_ < 0) v_ += m;
        return v_ - overflow;
      };
      this.pointer = 0;
      this.dataType = dataType, this.cells = cells, this.finiteCells = finiteCells, this.isBigInt = isBigInt;
      super.set(0, isBigInt ? BigInt(0) : 0);
      this.haltOnPointerOverflow = false;
    }
    getCurr() {
      return super.get(this.pointer);
    }
    setCurr(v) {
      if (v !== undefined)
        super.set(this.pointer, this.fixOverflow(v));
    }
    increment(i) {
      let v = super.get(this.pointer);
      super.set(this.pointer, this.fixOverflow(++v));
    }
    decrement(i) {
      let v = super.get(this.pointer);
      super.set(this.pointer, this.fixOverflow(--v));
    }
    right(i) {
      this.pointer++;
      if (this.pointer >= this.cells) {
        if (this.haltOnPointerOverflow)
          throw new Error("指针越界！");
        else
          this.pointer -= this.cells;
      }
      if (!super.has(this.pointer))
        super.set(this.pointer, this.isBigInt ? BigInt(0) : 0);
    }
    left(i) {
      this.pointer--;
      if (this.pointer < 0) {
        if (this.haltOnPointerOverflow)
          throw new Error("指针越界！");
        else if (this.finiteCells)
          this.pointer += this.cells;
      }
      if (!super.has(this.pointer))
        super.set(this.pointer, this.isBigInt ? BigInt(0) : 0);
    }
  }

  var intHandle;

  const vm = new Vue({
    el: "#app",
    
    data: {
      bigIntNotSupported: _test < 6,

      codeInputScrollTop: 0,

      code: `>+++++[-<+++++>]
>++++++++[-<++++++++>]
++++[->++++<]>[-<++++++>]
>++++[-<++++++++>]
<<<<+[->+.>+.>.<<<]
++++++++++.`,
      codeHighlight: "",
      syntaxError: false,
      
      config: {
        eof: undefined, // {undefined: no_change, -1, 0}
        dataType: 1, // {1: Int8, 2: Int16, 4: Int32, 8: Int64, 99: BigInt}
        _cells: 30000,
        cells: 30000, // {(int), Infinity}
        allowNegativeMP: false,
      },
      configVisible: false,
      customCellsVisible: false,

      tickSpeed: 300,
      tickSpeedVisible: false,

      panel: "edit", //edit, run, compile
      stat: "ready", // ready, run, pause, end
      codePointer: 0,
      breakpoints: new Set(),
      memory: null,
      staticInput: true,
      input: "",
      inputPointer: 0,
      inputBuffer: "",
      inputBufferEOF: false,
      waitingForInput: false,
      output: "",

      leaveLoopDepth: 0,
    },

    methods: {
      handleInput(raw, offset) {
        vm.code = raw;
        let frag = document.createDocumentFragment(),
          line = document.createElement("div"),
          token = null, text = null;
        let i = 0, l = raw.length, depth = 0, error = false, newLine = true;
        let caretNode = null, caretOffset = 1;
        if (i === 0 && offset === 0)
          caretNode = line, caretOffset = 0;
        while (i < l) {
          let char = raw[i++];
          if (char === "\n") {
            if (newLine) {
              text = document.createElement("br"),
              line.appendChild(text);
            }
            newLine = true;
            frag.appendChild(line);
            line = document.createElement("div");
            if (i === offset)
              caretNode = line, caretOffset = 0;
          } else {
            newLine = false;
            token = document.createElement("span"), text = document.createTextNode(char);
            token.classList.add("token");
            if (char === "+")
              token.classList.add("increment", "inserted");
            else if (char === "-")
              token.classList.add("decrement", "deleted");
            else if (char === "<" || char === ">")
              token.classList.add("pointer", "keyword");
            else if (char === "." || char === ",")
              token.classList.add("operator", "inserted");
            else if (char === "[")
              depth++, token.classList.add("branching", "important");
            else if (char === "]") {
              depth--, token.classList.add("branching", "important");
              if (depth < 0) 
                depth = 0, error = true, token.classList.add("soullbf-error");
            } else
              token.classList.add("comment");
            token.appendChild(text);
            line.appendChild(token);
            if (i === offset)
                caretNode = text, caretOffset = 1;
          }
          //console.log({i, depth, newLine, caretNode, caretOffset});
        }
        if (depth > 0)
          error = true,
          token.classList.add("soullbf-error");
        vm.syntaxError = error;
        if (newLine)
          line.appendChild(document.createElement("br"));
        frag.appendChild(line);
        return {
          renderedNode: frag,
          caretNode,
          caretOffset
        };
      },

      ucellsChange(v){
        if (v === undefined) {
          vm.config.cells = vm.config._cells;
          vm.customCellsVisible = true;
        }
        else
          vm.config._cells = v;
      },
      cellsChange(v){
        vm.config.cells = v;
      },

      renderMemory() {
        let m = [...vm.memory.entries()], r = [], i = vm.config.cells === Infinity && vm.config.allowNegativeMP ? -Infinity : -1;
        m.sort((l, r) => l[0] - r[0]);
        m.forEach((v) => {
          if (v[0] !== i + 1)
            r.push([i]);
          i = v[0];
          r.push(v);
        });
        if (vm.config.cells !== i + 1)
          r.push([i + 1]);
        return r;
      },

      inputBufferKeypress($event) {
        vm.input = vm.inputBuffer + "\n", vm.inputPointer = 0, vm.output += vm.input, vm.inputBuffer = "";
      },
      inputBufferEnded() {
        vm.inputBufferEOF = true;
        vm.input = vm.inputBuffer, vm.inputPointer = 0, vm.output += vm.input + "^C" + "\n", vm.inputBuffer = "";
      },

      codeClick($event) {
        let i = $event.target.dataset.i;
        if (i) {
          i = Number(i);
          console.log(i);
          if (vm.breakpoints.has(i))
            vm.breakpoints.delete(i);
          else if("><+-.,[]".includes(vm.code[i]))
            vm.breakpoints.add(i);
          vm.$forceUpdate();
        }
      },

      panelChange() {
        if (vm.panel === "edit")
          vm.reset();
        else if (vm.panel === "run")
          vm.init();
      },

      iStep() {
        let instruction = vm.code[vm.codePointer], cond = true;
        while (cond) {
          cond = false;
          if (instruction === undefined) 
            throw "程序退出！";
          
          switch (instruction) {
            case '>':
              vm.memory.right();
            break; case '<':
              vm.memory.left();
            break; case '+':
              vm.memory.increment();
            break; case '-':
              vm.memory.decrement();
            break; case '.':
              vm.output += String.fromCharCode(Number(vm.memory.getCurr()));
            break; case ',':
              if (vm.inputPointer < vm.input.length)
                vm.waitingForInput = false, vm.memory.setCurr(vm.input.charCodeAt(vm.inputPointer++));
              else if (vm.staticInput || vm.inputBufferEOF)
                vm.memory.setCurr(vm.config.eof);
              else {
                vm.waitingForInput = true;
                return;
              }
            break; case '[':
              let i3 = vm.code.substr(vm.codePointer), curr = vm.memory.getCurr();
              if (
                i3.match(/^\[([^><+-.,[\]]*)\-([^><+-.,[\]]*)\]/) && (vm.config.dataType !== 99 || curr > 0) ||
                i3.match(/^\[([^><+-.,[\]]*)\+([^><+-.,[\]]*)\]/) && (vm.config.dataType !== 99 || curr < 0)
              )
                vm.memory.setCurr(0), vm.codePointer += 2;
              else if (!curr) {
                let depth = 1;
                while (depth) {
                  instruction = vm.code[++vm.codePointer];
                  if (instruction === '[')
                    depth++;
                  else if (instruction === ']')
                    depth--;
                }
              }
            break; case ']':
              if (vm.memory.getCurr()) {
                let depth = 1;
                while (depth) {
                  instruction = vm.code[--vm.codePointer];
                  if (instruction === ']')
                    depth++;
                  else if (instruction === '[')
                    depth--;
                }
              }
            break; default:
              cond = true;
            break;
          }
          if (vm.output.length >= 131072)
            throw new Error("输出过长！");
          do
            instruction = vm.code[++vm.codePointer];
          while (instruction && !"><+-.,[]".includes(instruction));
        }
        if (vm.breakpoints.has(vm.codePointer))
          throw "break";
        vm.$nextTick(() => {
          let mt = vm.$el.querySelector(".soullbf-memory-table"),
            mp = mt.querySelector(".soullbf-pointer");
          mt.scrollLeft = mp.offsetLeft - mt.offsetWidth / 2;
          if (instruction === '.')
            vm.$el.querySelector(".soullbf-right").scrollTop = 2147483647;
        });
      },

      iHandleError(e) {
        clearTimeout(vm.intHandle);
          if (e instanceof Error) {
            vm.stat = 'end';
            vm.$message({
              type: 'error',
              message: e,
              duration: 0,
              showClose: true
            });
            throw e;
          }
          else if(e === "break") {
            vm.stat = 'pause';
          }
          else {
            vm.stat = 'end';
            vm.$message({
              type: 'success',
              message: e
            });
          }
      },

      init() {
        vm.panel = 'run';
        vm.stat = 'pause';
        vm.codePointer = 0;
        vm.inputPointer = 0;
        vm.output = "";
        vm.inputBuffer = "";
        vm.memory = new SoullbfMemory(vm.config.dataType, vm.config.cells);
        vm.memory.haltOnPointerOverflow = !vm.config.allowNegativeMP;
        vm.staticInput = Boolean(vm.input);
        vm.breakpoints = new Set();
        vm.inputBufferEOF = false;
      },
      run() {
        vm.stat = 'run';
        let f = () => {
          let end = Date.now() + 30;
          try {
            do
              vm.iStep();
            while (Date.now() < end);
            vm.intHandle = setTimeout(f, 10);
          } catch (e) {
            vm.iHandleError(e);
          }
        };
        f();
      },
      step() {
        vm.stat = 'pause';
        try {
          vm.iStep();
        } catch (e) {
          vm.iHandleError(e);
        }
      },
      pause() {
        vm.stat = 'pause';
        clearTimeout(vm.intHandle);
      },
      reset() {
        vm.stat = 'ready';
        vm.panel = 'edit';
        vm.codePointer = 0;
        vm.memory = null;
        if (!vm.staticInput)
          vm.input = "";
        vm.waitingForInput = false;
      },
    }
  });
</script>

</html>
